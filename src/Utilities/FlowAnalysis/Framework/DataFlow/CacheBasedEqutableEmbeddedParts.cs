
// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

// <auto-generated>
//  This code is autogenerated from CacheBasedEquatableEmbeddedParts.tt.
//
//  Changes to this file may cause incorrect behavior and will be lost if
//  the code is regenerated.
// </auto-generated>

using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using Analyzer.Utilities;

namespace Microsoft.CodeAnalysis.FlowAnalysis.DataFlow
{
    /// <summary>
    /// 1-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable1<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable1()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 1)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
        }

        /// <summary>
        /// Fills builder with at most 1 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable1<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0;
        }

        public static bool operator ==(CacheBasedEquatable1<T> value1, CacheBasedEquatable1<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable1<T> value1, CacheBasedEquatable1<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 2-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable2<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable2()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 2)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
        }

        /// <summary>
        /// Fills builder with at most 2 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable2<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1;
        }

        public static bool operator ==(CacheBasedEquatable2<T> value1, CacheBasedEquatable2<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable2<T> value1, CacheBasedEquatable2<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 3-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable3<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable3()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 3)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
        }

        /// <summary>
        /// Fills builder with at most 3 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable3<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2;
        }

        public static bool operator ==(CacheBasedEquatable3<T> value1, CacheBasedEquatable3<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable3<T> value1, CacheBasedEquatable3<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 4-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable4<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable4()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 4)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
        }

        /// <summary>
        /// Fills builder with at most 4 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable4<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3;
        }

        public static bool operator ==(CacheBasedEquatable4<T> value1, CacheBasedEquatable4<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable4<T> value1, CacheBasedEquatable4<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 5-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable5<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable5()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 5)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
        }

        /// <summary>
        /// Fills builder with at most 5 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable5<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4;
        }

        public static bool operator ==(CacheBasedEquatable5<T> value1, CacheBasedEquatable5<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable5<T> value1, CacheBasedEquatable5<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 6-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable6<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable6()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 6)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
        }

        /// <summary>
        /// Fills builder with at most 6 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable6<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5;
        }

        public static bool operator ==(CacheBasedEquatable6<T> value1, CacheBasedEquatable6<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable6<T> value1, CacheBasedEquatable6<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 7-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable7<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable7()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 7)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
        }

        /// <summary>
        /// Fills builder with at most 7 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable7<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6;
        }

        public static bool operator ==(CacheBasedEquatable7<T> value1, CacheBasedEquatable7<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable7<T> value1, CacheBasedEquatable7<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 8-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable8<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        int _lazyHashCodePart7;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable8()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 8)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
            if (builder.Count == 7) return;            
            _lazyHashCodePart7 = builder[7];
        }

        /// <summary>
        /// Fills builder with at most 8 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable8<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6
                && _lazyHashCodePart7 == otherEquatable._lazyHashCodePart7;
        }

        public static bool operator ==(CacheBasedEquatable8<T> value1, CacheBasedEquatable8<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable8<T> value1, CacheBasedEquatable8<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 9-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable9<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        int _lazyHashCodePart7;
        int _lazyHashCodePart8;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable9()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 9)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
            if (builder.Count == 7) return;            
            _lazyHashCodePart7 = builder[7];
            if (builder.Count == 8) return;            
            _lazyHashCodePart8 = builder[8];
        }

        /// <summary>
        /// Fills builder with at most 9 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable9<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6
                && _lazyHashCodePart7 == otherEquatable._lazyHashCodePart7
                && _lazyHashCodePart8 == otherEquatable._lazyHashCodePart8;
        }

        public static bool operator ==(CacheBasedEquatable9<T> value1, CacheBasedEquatable9<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable9<T> value1, CacheBasedEquatable9<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 10-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable10<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        int _lazyHashCodePart7;
        int _lazyHashCodePart8;
        int _lazyHashCodePart9;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable10()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 10)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
            if (builder.Count == 7) return;            
            _lazyHashCodePart7 = builder[7];
            if (builder.Count == 8) return;            
            _lazyHashCodePart8 = builder[8];
            if (builder.Count == 9) return;            
            _lazyHashCodePart9 = builder[9];
        }

        /// <summary>
        /// Fills builder with at most 10 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable10<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6
                && _lazyHashCodePart7 == otherEquatable._lazyHashCodePart7
                && _lazyHashCodePart8 == otherEquatable._lazyHashCodePart8
                && _lazyHashCodePart9 == otherEquatable._lazyHashCodePart9;
        }

        public static bool operator ==(CacheBasedEquatable10<T> value1, CacheBasedEquatable10<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable10<T> value1, CacheBasedEquatable10<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 11-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable11<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        int _lazyHashCodePart7;
        int _lazyHashCodePart8;
        int _lazyHashCodePart9;
        int _lazyHashCodePart10;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable11()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 11)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
            if (builder.Count == 7) return;            
            _lazyHashCodePart7 = builder[7];
            if (builder.Count == 8) return;            
            _lazyHashCodePart8 = builder[8];
            if (builder.Count == 9) return;            
            _lazyHashCodePart9 = builder[9];
            if (builder.Count == 10) return;            
            _lazyHashCodePart10 = builder[10];
        }

        /// <summary>
        /// Fills builder with at most 11 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable11<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6
                && _lazyHashCodePart7 == otherEquatable._lazyHashCodePart7
                && _lazyHashCodePart8 == otherEquatable._lazyHashCodePart8
                && _lazyHashCodePart9 == otherEquatable._lazyHashCodePart9
                && _lazyHashCodePart10 == otherEquatable._lazyHashCodePart10;
        }

        public static bool operator ==(CacheBasedEquatable11<T> value1, CacheBasedEquatable11<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable11<T> value1, CacheBasedEquatable11<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 12-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable12<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        int _lazyHashCodePart7;
        int _lazyHashCodePart8;
        int _lazyHashCodePart9;
        int _lazyHashCodePart10;
        int _lazyHashCodePart11;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable12()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 12)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
            if (builder.Count == 7) return;            
            _lazyHashCodePart7 = builder[7];
            if (builder.Count == 8) return;            
            _lazyHashCodePart8 = builder[8];
            if (builder.Count == 9) return;            
            _lazyHashCodePart9 = builder[9];
            if (builder.Count == 10) return;            
            _lazyHashCodePart10 = builder[10];
            if (builder.Count == 11) return;            
            _lazyHashCodePart11 = builder[11];
        }

        /// <summary>
        /// Fills builder with at most 12 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable12<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6
                && _lazyHashCodePart7 == otherEquatable._lazyHashCodePart7
                && _lazyHashCodePart8 == otherEquatable._lazyHashCodePart8
                && _lazyHashCodePart9 == otherEquatable._lazyHashCodePart9
                && _lazyHashCodePart10 == otherEquatable._lazyHashCodePart10
                && _lazyHashCodePart11 == otherEquatable._lazyHashCodePart11;
        }

        public static bool operator ==(CacheBasedEquatable12<T> value1, CacheBasedEquatable12<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable12<T> value1, CacheBasedEquatable12<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 13-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable13<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        int _lazyHashCodePart7;
        int _lazyHashCodePart8;
        int _lazyHashCodePart9;
        int _lazyHashCodePart10;
        int _lazyHashCodePart11;
        int _lazyHashCodePart12;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable13()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 13)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
            if (builder.Count == 7) return;            
            _lazyHashCodePart7 = builder[7];
            if (builder.Count == 8) return;            
            _lazyHashCodePart8 = builder[8];
            if (builder.Count == 9) return;            
            _lazyHashCodePart9 = builder[9];
            if (builder.Count == 10) return;            
            _lazyHashCodePart10 = builder[10];
            if (builder.Count == 11) return;            
            _lazyHashCodePart11 = builder[11];
            if (builder.Count == 12) return;            
            _lazyHashCodePart12 = builder[12];
        }

        /// <summary>
        /// Fills builder with at most 13 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable13<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6
                && _lazyHashCodePart7 == otherEquatable._lazyHashCodePart7
                && _lazyHashCodePart8 == otherEquatable._lazyHashCodePart8
                && _lazyHashCodePart9 == otherEquatable._lazyHashCodePart9
                && _lazyHashCodePart10 == otherEquatable._lazyHashCodePart10
                && _lazyHashCodePart11 == otherEquatable._lazyHashCodePart11
                && _lazyHashCodePart12 == otherEquatable._lazyHashCodePart12;
        }

        public static bool operator ==(CacheBasedEquatable13<T> value1, CacheBasedEquatable13<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable13<T> value1, CacheBasedEquatable13<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 14-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable14<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        int _lazyHashCodePart7;
        int _lazyHashCodePart8;
        int _lazyHashCodePart9;
        int _lazyHashCodePart10;
        int _lazyHashCodePart11;
        int _lazyHashCodePart12;
        int _lazyHashCodePart13;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable14()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 14)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
            if (builder.Count == 7) return;            
            _lazyHashCodePart7 = builder[7];
            if (builder.Count == 8) return;            
            _lazyHashCodePart8 = builder[8];
            if (builder.Count == 9) return;            
            _lazyHashCodePart9 = builder[9];
            if (builder.Count == 10) return;            
            _lazyHashCodePart10 = builder[10];
            if (builder.Count == 11) return;            
            _lazyHashCodePart11 = builder[11];
            if (builder.Count == 12) return;            
            _lazyHashCodePart12 = builder[12];
            if (builder.Count == 13) return;            
            _lazyHashCodePart13 = builder[13];
        }

        /// <summary>
        /// Fills builder with at most 14 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable14<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6
                && _lazyHashCodePart7 == otherEquatable._lazyHashCodePart7
                && _lazyHashCodePart8 == otherEquatable._lazyHashCodePart8
                && _lazyHashCodePart9 == otherEquatable._lazyHashCodePart9
                && _lazyHashCodePart10 == otherEquatable._lazyHashCodePart10
                && _lazyHashCodePart11 == otherEquatable._lazyHashCodePart11
                && _lazyHashCodePart12 == otherEquatable._lazyHashCodePart12
                && _lazyHashCodePart13 == otherEquatable._lazyHashCodePart13;
        }

        public static bool operator ==(CacheBasedEquatable14<T> value1, CacheBasedEquatable14<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable14<T> value1, CacheBasedEquatable14<T> value2)
        {
            return !(value1 == value2);
        }
    }

    /// <summary>
    /// 15-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable15<T> : IEquatable<T>
        where T: class
    {
        int _lazyHashCodePart0;
        int _lazyHashCodePart1;
        int _lazyHashCodePart2;
        int _lazyHashCodePart3;
        int _lazyHashCodePart4;
        int _lazyHashCodePart5;
        int _lazyHashCodePart6;
        int _lazyHashCodePart7;
        int _lazyHashCodePart8;
        int _lazyHashCodePart9;
        int _lazyHashCodePart10;
        int _lazyHashCodePart11;
        int _lazyHashCodePart12;
        int _lazyHashCodePart13;
        int _lazyHashCodePart14;
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable15()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > 15)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
            if (builder.Count == 0) return;            
            _lazyHashCodePart0 = builder[0];
            if (builder.Count == 1) return;            
            _lazyHashCodePart1 = builder[1];
            if (builder.Count == 2) return;            
            _lazyHashCodePart2 = builder[2];
            if (builder.Count == 3) return;            
            _lazyHashCodePart3 = builder[3];
            if (builder.Count == 4) return;            
            _lazyHashCodePart4 = builder[4];
            if (builder.Count == 5) return;            
            _lazyHashCodePart5 = builder[5];
            if (builder.Count == 6) return;            
            _lazyHashCodePart6 = builder[6];
            if (builder.Count == 7) return;            
            _lazyHashCodePart7 = builder[7];
            if (builder.Count == 8) return;            
            _lazyHashCodePart8 = builder[8];
            if (builder.Count == 9) return;            
            _lazyHashCodePart9 = builder[9];
            if (builder.Count == 10) return;            
            _lazyHashCodePart10 = builder[10];
            if (builder.Count == 11) return;            
            _lazyHashCodePart11 = builder[11];
            if (builder.Count == 12) return;            
            _lazyHashCodePart12 = builder[12];
            if (builder.Count == 13) return;            
            _lazyHashCodePart13 = builder[13];
            if (builder.Count == 14) return;            
            _lazyHashCodePart14 = builder[14];
        }

        /// <summary>
        /// Fills builder with at most 15 hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable15<T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
                && _lazyHashCodePart0 == otherEquatable._lazyHashCodePart0
                && _lazyHashCodePart1 == otherEquatable._lazyHashCodePart1
                && _lazyHashCodePart2 == otherEquatable._lazyHashCodePart2
                && _lazyHashCodePart3 == otherEquatable._lazyHashCodePart3
                && _lazyHashCodePart4 == otherEquatable._lazyHashCodePart4
                && _lazyHashCodePart5 == otherEquatable._lazyHashCodePart5
                && _lazyHashCodePart6 == otherEquatable._lazyHashCodePart6
                && _lazyHashCodePart7 == otherEquatable._lazyHashCodePart7
                && _lazyHashCodePart8 == otherEquatable._lazyHashCodePart8
                && _lazyHashCodePart9 == otherEquatable._lazyHashCodePart9
                && _lazyHashCodePart10 == otherEquatable._lazyHashCodePart10
                && _lazyHashCodePart11 == otherEquatable._lazyHashCodePart11
                && _lazyHashCodePart12 == otherEquatable._lazyHashCodePart12
                && _lazyHashCodePart13 == otherEquatable._lazyHashCodePart13
                && _lazyHashCodePart14 == otherEquatable._lazyHashCodePart14;
        }

        public static bool operator ==(CacheBasedEquatable15<T> value1, CacheBasedEquatable15<T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable15<T> value1, CacheBasedEquatable15<T> value2)
        {
            return !(value1 == value2);
        }
    }
}
