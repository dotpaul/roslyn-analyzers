<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>

// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

// <auto-generated>
//  This code is autogenerated from CacheBasedEquatableEmbeddedParts.tt.
//
//  Changes to this file may cause incorrect behavior and will be lost if
//  the code is regenerated.
// </auto-generated>

using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using Analyzer.Utilities;

namespace Microsoft.CodeAnalysis.FlowAnalysis.DataFlow
{
<#
    for (int nParts = 1; nParts <= 15; nParts++)
    {
        if (nParts > 1)
        {
#>

<#          
        }
#>
    /// <summary>
    /// <#= nParts#>-part abstract cache based equatable implementation for objects that are compared frequently and hence need a performance optimization of using a cached hash code.
    /// </summary>
    internal abstract class CacheBasedEquatable<#= nParts#><T> : IEquatable<T>
        where T: class
    {
<#
        for (int i = 0; i < nParts; i++)
        {
#>
        int _lazyHashCodePart<#= i#>;
<#
        }
#>
        private int _lazyHashCode;
        private int _lazyHashCodePartsCount = -1;

        protected CacheBasedEquatable<#= nParts#>()
        {
        }

        private int GetOrComputeHashCode()
        {
            if (_lazyHashCodePartsCount < 0)
            {
                lock (this)
                {
                    var builder = ArrayBuilder<int>.GetInstance();
                    try
                    {
                        ComputeHashCodeParts(builder);
                        if (builder.Count > <#= nParts#>)
                        {
                            throw new InvalidOperationException($"Number of hash code parts exceeds capacity.  {GetType().ToString()} derives from the wrong class.");
                        }

                        var hashCode = HashUtilities.Combine(builder, builder.Count, GetType().GetHashCode());

                        _lazyHashCode = hashCode;
                        AssignLazyHashCodeParts(builder);
                        _lazyHashCodePartsCount = builder.Count;
                    }
                    finally
                    {
                        builder.Free();
                    }
                }
            }

            return _lazyHashCode;
        }

        private void AssignLazyHashCodeParts(ArrayBuilder<int> builder)
        {
<#
        for (int i = 0; i < nParts; i++)
        {
#>
            if (builder.Count == <#= i#>) return;            
            _lazyHashCodePart<#= i#> = builder[<#= i#>];
<#
        }
#>
        }

        /// <summary>
        /// Fills builder with at most <#= nParts#> hash code parts.
        /// </summary>
        protected abstract void ComputeHashCodeParts(ArrayBuilder<int> builder);

        public sealed override int GetHashCode() => GetOrComputeHashCode();

        public sealed override bool Equals(object obj) => Equals(obj as T);
        public bool Equals(T other)
        {
            // Perform fast equality checks first.
            if (ReferenceEquals(this, other))
            {
                return true;
            }

            var otherEquatable = other as CacheBasedEquatable<#= nParts#><T>;
            if (otherEquatable == null || GetHashCode() != otherEquatable.GetHashCode())
            {
                return false;
            }

            // Now perform slow check that compares individual hash code parts sequences.
            Debug.Assert(_lazyHashCodePartsCount >= 0);
            Debug.Assert(otherEquatable._lazyHashCodePartsCount >= 0);
            return _lazyHashCodePartsCount == otherEquatable._lazyHashCodePartsCount
<#
        for (int i = 0; i <nParts; i++)
        {
#>
                && _lazyHashCodePart<#= i#> == otherEquatable._lazyHashCodePart<#= i#><#= i == nParts - 1 ? ";" : "" #>
<#
        }
#>
        }

        public static bool operator ==(CacheBasedEquatable<#= nParts#><T> value1, CacheBasedEquatable<#= nParts#><T> value2)
        {
            if ((object)value1 == null)
            {
                return (object)value2 == null;
            }
            else if ((object)value2 == null)
            {
                return false;
            }

            return value1.Equals(value2);
        }

        public static bool operator !=(CacheBasedEquatable<#= nParts#><T> value1, CacheBasedEquatable<#= nParts#><T> value2)
        {
            return !(value1 == value2);
        }
    }
<#
        // end of for (int nParts = 1; nParts <= 4; nParts++)
    }     
#>
}
